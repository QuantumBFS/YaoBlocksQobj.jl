var documenterSearchIndex = {"docs":
[{"location":"#YaoBlocksQobj","page":"Quickstart","title":"YaoBlocksQobj","text":"","category":"section"},{"location":"","page":"Quickstart","title":"Quickstart","text":"(Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Quickstart","title":"Quickstart","text":"YaoBlocks interafce for the IBMQClient package.","category":"page"},{"location":"#Usage","page":"Quickstart","title":"Usage","text":"","category":"section"},{"location":"","page":"Quickstart","title":"Quickstart","text":"Create a circuit","category":"page"},{"location":"","page":"Quickstart","title":"Quickstart","text":"using Yao, YaoBlocksQobj\nqc = chain(3, put(1=>X), put(2=>Y) ,put(3=>Z), \n                put(2=>T), swap(1,2), put(3=>Ry(0.7)), \n                control(2, 1=>Y), control(3, 2=>Z))","category":"page"},{"location":"","page":"Quickstart","title":"Quickstart","text":"Creating headers is optional but if they should be in order for respective experiemnts","category":"page"},{"location":"","page":"Quickstart","title":"Quickstart","text":"# main header for the job\nheader = Dict(\"description\"=>\"test circuits\")\n\n# header for the experiments\nexp_header = [Dict(\"description\"=>\"1\")]","category":"page"},{"location":"","page":"Quickstart","title":"Quickstart","text":"Creating a Qobj","category":"page"},{"location":"","page":"Quickstart","title":"Quickstart","text":"q = create_qobj([qc], id = \"test_id\", header= header, exp_header = exp_header)","category":"page"},{"location":"refs/#API-References","page":"API References","title":"API References","text":"","category":"section"},{"location":"refs/","page":"API References","title":"API References","text":"Modules = [YaoBlocksQobj]","category":"page"},{"location":"refs/#YaoBlocksQobj.convert_to_qbir-Tuple{Any}","page":"API References","title":"YaoBlocksQobj.convert_to_qbir","text":"convert_to_qbir(inst)\n\nConverts Qobj based instructions back to YaoIR.\n\ninst: The Qobj based instructions.\n\nFor Example:\n\nq = convert_to_qobj(chain(1, put(1 => H))) \nir = q.experiments[1].instructions |> convert_to_qbir\n\n\n\n\n\n","category":"method"},{"location":"refs/#YaoBlocksQobj.create_experiment-Union{Tuple{N}, Tuple{Vector{var\"#s16\"} where var\"#s16\"<:YaoAPI.AbstractBlock{N}, Nothing, Nothing}} where N","page":"API References","title":"YaoBlocksQobj.create_experiment","text":"create_experiment(qc, exp_header, exp_config)\n\nReturns and experiment type that consits of instructions.\n\nqc: An Array of ChainBlock(circuits that are to be run).\nexp_header(optional): Array of User-defined structure that contains metadata on each experiment and\n\nis not used by the backend. The header will be passed through to the result data structure unchanged.  For example, this may contain a fitting parameters for the experiment. In addition, this header can  contain a mapping of backend memory and backend qubits to OpenQASM registers.  This is because an OpenQASM circuit may contain multiple classical and quantum registers,  but Qobj flattens them into a single memory and single set of qubits.\n\nexp_config (optional): An Array of Configuration structure for user settings that can be different in each\n\nexperiment. These will override the configuration settings of the whole job.\n\n\n\n\n\n","category":"method"},{"location":"refs/#YaoBlocksQobj.generate_inst-Union{Tuple{YaoAPI.AbstractBlock{N}}, Tuple{N}} where N","page":"API References","title":"YaoBlocksQobj.generate_inst","text":"generate_inst(qc)\n\nParses the YaoIR into a list of IBMQ supported instructions\n\nqc: A ChainBlock(circuit that is to be run).\n\n\n\n\n\n","category":"method"}]
}
